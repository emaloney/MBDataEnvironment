<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>MBMLDataProcessingFunctions Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1333)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">Mockingbird Data Environment </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">Gilt Groupe</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	
	<optgroup label="Class Methods">
		
		<option value="//api/name/appendArrays:">+ appendArrays:</option>
		
		<option value="//api/name/associate:">+ associate:</option>
		
		<option value="//api/name/associateWithArray:">+ associateWithArray:</option>
		
		<option value="//api/name/associateWithSingleValue:">+ associateWithSingleValue:</option>
		
		<option value="//api/name/collectionPassesTest:">+ collectionPassesTest:</option>
		
		<option value="//api/name/containsValue:">+ containsValue:</option>
		
		<option value="//api/name/distributeArrayElements:">+ distributeArrayElements:</option>
		
		<option value="//api/name/filter:">+ filter:</option>
		
		<option value="//api/name/flattenArrays:">+ flattenArrays:</option>
		
		<option value="//api/name/groupArrayElements:">+ groupArrayElements:</option>
		
		<option value="//api/name/join:">+ join:</option>
		
		<option value="//api/name/list:">+ list:</option>
		
		<option value="//api/name/mergeDictionaries:">+ mergeDictionaries:</option>
		
		<option value="//api/name/pruneMatchingLeaves:">+ pruneMatchingLeaves:</option>
		
		<option value="//api/name/pruneNonmatchingLeaves:">+ pruneNonmatchingLeaves:</option>
		
		<option value="//api/name/reduce:">+ reduce:</option>
		
		<option value="//api/name/reverse:">+ reverse:</option>
		
		<option value="//api/name/selectFirstValue:">+ selectFirstValue:</option>
		
		<option value="//api/name/setContains:">+ setContains:</option>
		
		<option value="//api/name/sort:">+ sort:</option>
		
		<option value="//api/name/split:">+ split:</option>
		
		<option value="//api/name/splitLines:">+ splitLines:</option>
		
		<option value="//api/name/unique:">+ unique:</option>
		
		<option value="//api/name/valuesIntersect:">+ valuesIntersect:</option>
		
		<option value="//api/name/valuesPassingTest:">+ valuesPassingTest:</option>
		
	</optgroup>
	

	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">MBMLDataProcessingFunctions Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>MBMLDataProcessingFunctions.h</td>
</tr>
						</tbody></table></div>
					

                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>This class provides a set of MBML functions for manipulating data structures.</p>

<h3>Terminology</h3>

<p><strong>Collection objects:</strong> Where objects are referred to as <em>collections</em>, any
object implementing <code>NSFastEnumeration</code> may be used. Typically, collections
are <code>NSDictionary</code>, <code>NSArray</code> or <code>NSSet</code> instances.</p>

<h3>About function declarations</h3>

<p>These functions are exposed to the Mockingbird environment via
<code>&lt;Function ... /&gt;</code> declarations in the <code><a href="../Classes/MBDataEnvironmentModule.html">MBDataEnvironmentModule</a>.xml</code>
file.</p>

<p>For more information on MBML functions, see the <a href="../Classes/MBMLFunction.html"><code>MBMLFunction</code></a> class.</p>
					</div>
					
					

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						<a title="Testing collections" name="task_Testing collections"></a>
						<h2 class="task-title">Testing collections</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/containsValue:" title="containsValue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/containsValue:">+&nbsp;containsValue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Determines whether one or more <em>collections</em> contains a specified <em>value</em>.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)containsValue:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p><code>@YES</code> if any of the input <em>collections</em> contains the <em>test value</em>;
            <code>@NO</code> otherwise.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>One or more <em>collections</em>, object expressions yielding collection instances.</p></li>
<li><p>The <em>test value</em>, an object expression yielding the value be used to test
equality with the values in the passed-in <em>collections</em>.</p></li>
</ul>


<p><strong>Note:</strong> This method tests equality using <a href="../Classes/MBExpression.html#//api/name/value:isEqualTo:"><code>[MBExpression value:isEqualTo:]</code></a>,
not the standard <code>isEqual:</code> method. This allows implicit type conversions to
occur, so that an <code>NSNumber</code> containing the integer <code>5</code> is considered equal
to an <code>NSString</code> containing the text &ldquo;<code>5</code>&rdquo;.</p>

<h4>Expression usage</h4>

<pre><code>^containsValue($colorsOne|$colorsTwo|yellow)
</code></pre>

<p>The expression above will evaluate to <code>true</code> if either <code>$colorsOne</code> or
<code>$colorsTwo</code> contains an item whose value is the string &ldquo;<code>yellow</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/setContains:">+ setContains:</a>, <a href="#//api/name/collectionPassesTest:">+ collectionPassesTest:</a>, <a href="#//api/name/valuesPassingTest:">+ valuesPassingTest:</a>,
            <a href="#//api/name/valuesIntersect:">+ valuesIntersect:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setContains:" title="setContains:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setContains:">+&nbsp;setContains:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Determines whether an <code>NSSet</code> contains a given object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)setContains:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p><code>@YES</code> if the input <em>set</em> contains the <em>test value</em>; <code>@NO</code>
            otherwise.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Because this function is optimized to work with <code>NSSet</code> instances, it is
more efficient than using <code>^containsValue()</code> for the same purpose.</p>

<p>This function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>set</em>, an object expression yielding an <code>NSSet</code> instance.</p></li>
<li><p>The <em>test value</em>, an object expression yielding the value whose presence
within <em>set</em> is to be detected.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that the MBML variable <code>$colors</code> is a set containing the values &ldquo;<code>red</code>&rdquo;,
&ldquo;<code>yellow</code>&rdquo;, &ldquo;<code>green</code>&rdquo;, and &ldquo;<code>blue</code>&rdquo;:</p>

<pre><code>^setContains($colors|orange)
</code></pre>

<p>The expression above would evaluate to <code>false</code> because <code>$colors</code> does not
contain the value &ldquo;<code>orange</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/containsValue:">+ containsValue:</a>, <a href="#//api/name/collectionPassesTest:">+ collectionPassesTest:</a>, <a href="#//api/name/valuesPassingTest:">+ valuesPassingTest:</a>,
            <a href="#//api/name/valuesIntersect:">+ valuesIntersect:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/collectionPassesTest:" title="collectionPassesTest:"></a>
	<h3 class="method-title"><code><a href="#//api/name/collectionPassesTest:">+&nbsp;collectionPassesTest:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Applies a boolean expression <em>test</em> to each member of a <em>collection</em> and
returns <code>@YES</code> if and only if the expression <em>test</em> evaluates to <code>true</code>
for every item in the collection.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)collectionPassesTest:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p><code>@YES</code> if every item in the collection passes the <em>test</em>; <code>NO</code>
            otherwise.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>collection</em>, an object expression yielding a collection instance.</p></li>
<li><p>The <em>test</em>, a boolean expression that will be used to test each value in the
passed-in collection.</p></li>
</ul>


<p><strong>Note:</strong> This method tests equality using <a href="../Classes/MBExpression.html#//api/name/value:isEqualTo:"><code>[MBExpression value:isEqualTo:]</code></a>,
not the standard <code>isEqual:</code> method. This allows implicit type conversions to
occur, so that an <code>NSNumber</code> containing the integer <code>5</code> is considered equal
to an <code>NSString</code> containing the text &ldquo;<code>5</code>&rdquo;.</p>

<h4>Expression usage</h4>

<pre><code>^collectionPassesTest($collection|$item.length -GT 0)
</code></pre>

<p>The expression above would evaluate to <code>true</code> if all the members of
<code>$collection</code> have a length greater than <code>0</code>.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/valuesPassingTest:">+ valuesPassingTest:</a>, <a href="#//api/name/containsValue:">+ containsValue:</a>, <a href="#//api/name/setContains:">+ setContains:</a>,
            <a href="#//api/name/valuesIntersect:">+ valuesIntersect:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/selectFirstValue:" title="selectFirstValue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/selectFirstValue:">+&nbsp;selectFirstValue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Selects the first non-<code>nil</code> (and non-<code>NSNull</code>) value from among two or
more parameters.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)selectFirstValue:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>an array containing the input parameters for the function</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The result of performing the evaluations described above.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more object expressions as input
parameters and returns the result of the first expression returning a valid
value.</p>

<h4>Expression usage</h4>

<pre><code> ^selectFirstValue($dataSource|^array())
</code></pre>

<p>The expression above would return the value of <code>$dataSource</code>
if it a non-<code>nil</code>/non-<code>NSNull</code> value; otherwise, an empty array is returned.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/valuesPassingTest:" title="valuesPassingTest:"></a>
	<h3 class="method-title"><code><a href="#//api/name/valuesPassingTest:">+&nbsp;valuesPassingTest:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Evaluates a boolean <em>test</em> expression against each value in one or more
<em>collections</em>, and returns an array containing the collection values
for which <em>test</em> evaluates to <code>true</code>.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)valuesPassingTest:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing the values in the collections for which the
            test expression evaluates to <code>true</code>.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more pipe-separated expressions
yielding:</p>

<ul>
<li><p>One or more <em>data models</em>, object expressions yielding collection instances.</p></li>
<li><p>The <em>test expression</em>, an expression that will be evaluated for each
value in each passed-in data model.</p></li>
</ul>


<p>The test expression can refer to the following pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value in a collection object that&rsquo;s currently being
tested.</p></li>
<li><p>When the collection being tested is a dictionary, <code>$key</code> can be used to
access the key associated with the current <code>$item</code>.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$articles</code> and <code>$videos</code> are collections whose values each have
a <code>displayOrder</code> attribute:</p>

<pre><code>^valuesPassingTest($articles|$videos|$item.displayOrder -EQ 1)
</code></pre>

<p>The expression above would iterate over all the values in the
<code>$articles</code> and then the <code>$videos</code> collection objects, and
for each value, it would perform a <code>$item.displayOrder -EQ 1</code> boolean
test. Each value in <code>$articles</code> and <code>$videos</code> for which
the expression <code>$item.displayOrder -EQ 1</code> evaluates to <code>true</code> will be
placed into the array returned by the function.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/collectionPassesTest:">+ collectionPassesTest:</a>, <a href="#//api/name/containsValue:">+ containsValue:</a>, <a href="#//api/name/setContains:">+ setContains:</a>,
            <a href="#//api/name/valuesIntersect:">+ valuesIntersect:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/valuesIntersect:" title="valuesIntersect:"></a>
	<h3 class="method-title"><code><a href="#//api/name/valuesIntersect:">+&nbsp;valuesIntersect:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Tests whether two collections share at least one value in common.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)valuesIntersect:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p><code>@YES</code> if the two collection objects share at least one common
            value, <code>@NO</code> if they do not.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated object expressions
yielding the collection objects to test.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$boys</code> is an <code>NSSet</code> containing the strings &ldquo;<code>Bob</code>&rdquo;, &ldquo;<code>Joe</code>&rdquo; and
&ldquo;<code>Pat</code>&rdquo;, and that <code>$girls</code> is an <code>NSSet</code> containing the strings &ldquo;<code>Alice</code>&rdquo;,
&ldquo;<code>Pat</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>

<pre><code>^valuesIntersect($boys|$girls)
</code></pre>

<p>The expression above would evaluate to <code>true</code> because both <code>$boys</code> and <code>$girls</code>
share a common value: the string &ldquo;<code>Pat</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/collectionPassesTest:">+ collectionPassesTest:</a>, <a href="#//api/name/containsValue:">+ containsValue:</a>, <a href="#//api/name/setContains:">+ setContains:</a>,
            <a href="#//api/name/valuesPassingTest:">+ valuesPassingTest:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Joining &amp; splitting strings" name="task_Joining &amp; splitting strings"></a>
						<h2 class="task-title">Joining &amp; splitting strings</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/join:" title="join:"></a>
	<h3 class="method-title"><code><a href="#//api/name/join:">+&nbsp;join:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates a string by concatenating the string values of the elements in one or
more collections, using the specified separator string between each value in
the returned string.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)join:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>A string containing the string values of the items in the
            <em>collections</em>, separated by the string specified as the <em>separator</em>.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>One or more <em>collections</em>, object expressions that evaluate to collection
instances.</p></li>
<li><p>The <em>separator</em>, a string expression yielding the separator to be used
between each value in the returned string.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$values</code> is an array containing the strings &ldquo;<code>string1</code>&rdquo;,
&ldquo;<code>anotherString</code>&rdquo;, and &ldquo;<code>lastly</code>&rdquo;:</p>

<pre><code>^join($values|, )
</code></pre>

<p>The expression above would yield the string &ldquo;<code>string1, anotherString, lastly</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/split:">+ split:</a>, <a href="#//api/name/splitLines:">+ splitLines:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/split:" title="split:"></a>
	<h3 class="method-title"><code><a href="#//api/name/split:">+&nbsp;split:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates an array by splitting a string on a given delimeter.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)split:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing the components of the split string.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated string expressions as
parameters:</p>

<ul>
<li><p>The <em>delimiter</em>, which specifies where the <em>input string</em> will be split.</p></li>
<li><p>The <em>input string</em>, which is the string to be split.</p></li>
</ul>


<h4>Expression usage:</h4>

<pre><code>^split(, |Evan, Jesse, Yon)
</code></pre>

<p>The expression above would return an array containing three elements:
&ldquo;<code>Evan</code>&rdquo;, &ldquo;<code>Jesse</code>&rdquo;, and &ldquo;<code>Yon</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/join:">+ join:</a>, <a href="#//api/name/splitLines:">+ splitLines:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/splitLines:" title="splitLines:"></a>
	<h3 class="method-title"><code><a href="#//api/name/splitLines:">+&nbsp;splitLines:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates an array by splitting a string at newlines.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)splitLines:(NSString *)<em>stringToSplit</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>stringToSplit</code></th>
						<td><p>The string being split.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An <code>NSArray</code> containing the individual lines of <code>stringToSplit</code>.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This function accepts a single Mockingbird expression, an expression yielding
the string to be split.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$lines</code> is a string containing newlines:</p>

<pre><code>^splitLines($lines)
</code></pre>

<p>The expression above would return an array containing one element for each
line in <code>$lines</code>, where each element contains a single line of text (with
newlines stripped off).</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/split:">+ split:</a>, <a href="#//api/name/join:">+ join:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Manipulating arrays" name="task_Manipulating arrays"></a>
						<h2 class="task-title">Manipulating arrays</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/appendArrays:" title="appendArrays:"></a>
	<h3 class="method-title"><code><a href="#//api/name/appendArrays:">+&nbsp;appendArrays:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a single array containing all the elements in the arrays specified
in the input parameters.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)appendArrays:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing all of the elements in the arrays referenced
            by the passed-in expression parameters.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more pipe-separated object expressions
as parameters, where each expression yields an <code>NSArray</code> instance.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$array1</code>, <code>$array2</code> and <code>$array3</code> resolve to array values:</p>

<pre><code>^appendArrays($array1|$array2|$array3)
</code></pre>

<p>The expression above will evaluate to a single array, wherein the returned
array will contain all the elements of <code>$array1</code>, in the same order they
appear in the array, followed by the elements of <code>$array2</code>, and then those
of <code>$array3</code>.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/flattenArrays:" title="flattenArrays:"></a>
	<h3 class="method-title"><code><a href="#//api/name/flattenArrays:">+&nbsp;flattenArrays:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Accepts one or more input arrays and returns a single array containing a
flattened version of the contents of the input arrays.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)flattenArrays:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The flattened array.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Flattening involves removing nested arrays such that all non-arrays contained
at any level of nesting in the input arrays will become elements in the
returned array. The returned array will contain no elements that are themselves
<code>NSArray</code> instances.</p>

<p>Flattening is performed with a depth-first traversal of the input arrays.</p>

<p>This Mockingbird function accepts one or more pipe-separated object expressions
as parameters, where each expression yields an <code>NSArray</code> instance.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$nestedArrays</code> refers to an array wherein each element is
another array:</p>

<pre><code>^flattenArrays($nestedArrays)
</code></pre>

<p>The example above would return an array containing the elements of each array
contained in <code>$nestedArrays</code>.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Manipulating dictionaries" name="task_Manipulating dictionaries"></a>
						<h2 class="task-title">Manipulating dictionaries</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/mergeDictionaries:" title="mergeDictionaries:"></a>
	<h3 class="method-title"><code><a href="#//api/name/mergeDictionaries:">+&nbsp;mergeDictionaries:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Merges the keys and values contained in multiple dictionaries into a single
dictionary.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)mergeDictionaries:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts at least two pipe-separated object
expressions yielding <code>NSDictionary</code> instances as input parameters:</p>

<ul>
<li><p>The <em>first input dictionary</em></p></li>
<li><p>The <em>second input dictionary</em></p></li>
<li><p>Zero or more <em>additional input dictionaries</em></p></li>
</ul>


<p>The return value will be the result of overlaying the values of each input
dictionary parameter with the dictionary parameter that preceded it. The
resulting dictionary will contain keys from all input dictionaries, and if
there are any duplicate keys, the value from the right-most parameter
will be selected.</p>

<p>For example, if <em>second input dictionary</em> contains a value for a key that&rsquo;s
also present in <em>first input dictionary</em>, the key/value pair from <em>second input
dictionary</em> will overwrite the first.</p>

<h4>Expression usage</h4>

<p>For example, in the expression:</p>

<pre><code>^mergeDictionaries($localUsers|$remoteUsers|$automatedUsers)
</code></pre>

<p>The dictionaries yielded by the expressions <code>$localUsers</code>, <code>$remoteUsers</code> and
<code>$automatedUsers</code> are merged such that:</p>

<ul>
<li><p>Each key/value pair in <code>$automatedUsers</code> will be present in the returned
 dictionary</p></li>
<li><p>For each key in <code>$remoteUsers</code> not present in <code>$automatedUsers</code>, the
 key/value in <code>$remoteUsers</code> will be present in the returned dictionary</p></li>
<li><p>For each key in <code>$localUsers</code> not present in <code>$remoteUsers</code> or
 <code>$automatedUsers</code>, the key/value in <code>$localUsers</code> will be present in the
 returned dictionary</p></li>
</ul>

			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Pruning trees" name="task_Pruning trees"></a>
						<h2 class="task-title">Pruning trees</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/pruneMatchingLeaves:" title="pruneMatchingLeaves:"></a>
	<h3 class="method-title"><code><a href="#//api/name/pruneMatchingLeaves:">+&nbsp;pruneMatchingLeaves:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Traverses an array-based tree structure, removing any leaves (non-arrays)
whose values match a given test expression. The resulting pruned tree is then
returned in an array.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)pruneMatchingLeaves:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>input array</em>, an object expression yielding an <code>NSArray</code> representing
the root of the tree.</p></li>
<li><p>The <em>test</em>, a boolean expression that will be evaluated once for each
non-array element found while traversing the tree.</p></li>
</ul>


<p>The function will return a tree structure similar to the input structure, but
where all leaf elements for which <em>test</em> evaluates to <code>true</code> have been removed.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$input</code> is an array containing two inner arrays. The first inner
array contains the strings: &ldquo;<code>Bob</code>&rdquo;, &ldquo;<code>Joe</code>&rdquo; and &ldquo;<code>Pat</code>&rdquo;; the second inner
array contains: &ldquo;<code>Alice</code>&rdquo;, &ldquo;<code>Pat</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>

<pre><code>^pruneMatchingLeaves($input|$item -EQ Pat)
</code></pre>

<p>The expression above would return an array containing two inner arrays,
the first having the elements &ldquo;<code>Bob</code>&rdquo; and &ldquo;<code>Joe</code>&rdquo;, and the second having
the elements &ldquo;<code>Alice</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/pruneNonmatchingLeaves:">+ pruneNonmatchingLeaves:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/pruneNonmatchingLeaves:" title="pruneNonmatchingLeaves:"></a>
	<h3 class="method-title"><code><a href="#//api/name/pruneNonmatchingLeaves:">+&nbsp;pruneNonmatchingLeaves:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Traverses an array-based tree structure, removing any leaves (non-arrays)
whose values do not match a given test expression. The resulting pruned tree
is then returned in an array.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)pruneNonmatchingLeaves:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>input array</em>, an object expression yielding an <code>NSArray</code> representing
the root of the tree.</p></li>
<li><p>The <em>test</em>, a boolean expression that will be evaluated once for each
non-array element found while traversing the tree.</p></li>
</ul>


<p>The function will return a tree structure similar to the input structure, but
where all leaf elements for which <em>test</em> evaluates to <code>false</code> have been
removed.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$input</code> is an array containing two inner arrays. The first inner
array contains the strings: &ldquo;<code>Bob</code>&rdquo;, &ldquo;<code>Joe</code>&rdquo; and &ldquo;<code>Pat</code>&rdquo;; the second inner
array contains: &ldquo;<code>Alice</code>&rdquo;, &ldquo;<code>Pat</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>

<pre><code>^pruneNonmatchingLeaves($input|$item -EQ Pat)
</code></pre>

<p>The expression above would return an array containing two inner arrays,
each with a single element: &ldquo;<code>Pat</code>&rdquo;.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/pruneMatchingLeaves:">+ pruneMatchingLeaves:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Extracting data" name="task_Extracting data"></a>
						<h2 class="task-title">Extracting data</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/filter:" title="filter:"></a>
	<h3 class="method-title"><code><a href="#//api/name/filter:">+&nbsp;filter:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Filters a data model by applying a test expression against each item in the
collection.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)filter:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array or dictionary containing the filtered items. If the <em>data
            model</em> collection is a dictionary, the returned value will be a
            dictionary. Otherwise, an array will be returned.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an object expression yielding the collection instance to
be filtered.</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse into
portions of the data model.</p></li>
<li><p>The <em>test</em>, a boolean expression used to determine which values pass through
the filter.</p></li>
<li><p>Finally, an optional <em>filter behavior</em>, which can be either
<code>matchAtLeastOnce</code> or <code>matchAll</code>. Note that <strong>only</strong> these text literals are
acceptable values if this parameter is provided; this parameter is not
evaluated as an expression. If this parameter is omitted, <code>matchAtLeastOnce</code>
filtering behavior will be used.</p></li>
</ul>


<h4>Filter behaviors</h4>

<p>Intermediate expressions make it possible to recurse into the data model
to apply the test expression to values below the top level of the data model.</p>

<p>As a result, when intermediate expressions are used, for any given top-level
object, the test expression may be applied multiple times.</p>

<p>The filter behavior determines when the top-level object will pass through
the filter:</p>

<ul>
<li><p><code>matchAtLeastOnce</code>: If <em>test</em> is evaluated multiple times for a given
top-level object, that object will pass through the filter if <em>test</em> evaluates
to <code>true</code> at least once.</p></li>
<li><p><code>matchAll</code>:  If <em>test</em> is evaluated multiple times for a given
top-level object, that object will pass through the filter <strong>only</strong> if <em>test</em>
evaluates to <code>true</code> every time.</p></li>
</ul>


<p>If no intermediate expressions are used, <em>test</em> will only be evaluated once for
a given top-level object, so there is no effective difference between the
behavior of these two options.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^filter($people|$item.children|$item.aunt|$item.firstName -EQ Jill|matchAll)
</code></pre>

<p>The expression above would return all <em>persons</em> contained in <code>$people</code> where
every aunt of every child of the <em>person</em> has the first name &ldquo;<code>Jill</code>&rdquo;.</p>

<p>The <code>matchAll</code> parameter can be omitted to return every <em>person</em> with at least
one child who has at least one aunt with the first name &ldquo;<code>Jill</code>&rdquo;.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/list:" title="list:"></a>
	<h3 class="method-title"><code><a href="#//api/name/list:">+&nbsp;list:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Iterates over (and potentially recurses into) the items in a collection object
holding an arbitrary data model, and returns an <code>NSArray</code> containing a list of
values. The values in the returned array will reflect the ordering of any
arrays iterated; however, iterating dictionaries or sets will result in
non-deterministic ordering.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)list:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an object expression yielding the collection object to be
iterated.</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model.</p></li>
<li><p>A <em>value expression</em>, which will be evaluated once for each item encountered
while iterating the data model and recursing into any intermediate expressions.</p></li>
</ul>


<p>The function will return an array containing the result of evaluating the
<em>value expression</em> once for each item encountered while traversing the data
model.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$states</code> is a dictionary where each item in the dictionary
represents a state. The key for each item is the two-letter postal code for the
state, and the value associated with each key is another dictionary containing
additional information about the state.</p>

<pre><code>^list($states
     |$item.citiesBySize
     |$item.name, $root:key - $item.population residents)
</code></pre>

<p>The expression above would iterate over all the elements in the <code>$states</code>
dictionary, and for each state, it would then iterate over the elements
contained in the states&rsquo;s <code>cityBySize</code> property, which in this case is an
ordered array of cities in the state sorted by population.</p>

<p>For each city in each state&rsquo;s <code>cityBySize</code>, the returned array would
contain a string with values such as:</p>

<pre><code>New York, NY - 8,391,881 residents
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/associate:" title="associate:"></a>
	<h3 class="method-title"><code><a href="#//api/name/associate:">+&nbsp;associate:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Associates a set of keys with values by iterating over (and potentially
recursing into) a collection object holding an arbitrary data model. If the
association would result in more than one value for a given key, the multiple
values will be placed into an array.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)associate:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts three or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an object expression yielding a <em>collection</em> to be
used as the source for the keys and values in the returned dictionary.</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model.</p></li>
<li><p>The second-to-last expression in the input parameters is the <em>key
expression</em>, which yields the keys contained in the returned dictionary.</p></li>
<li><p>The last expression is the <em>value expression</em>, which yields the values
contained in the returned dictionary.</p></li>
</ul>


<p>The intermediate, key and value expressions can refer to portions of the
data model using several pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value of the current item in the innermost
scope being iterated/recursed.</p></li>
<li><p>When iterating the values of a dictionary, the <code>$key</code> variable
can be used to access the key associated with the current <code>$item</code>.</p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model.</p></li>
<li><p>When the data model collection is a dictionary, <code>$rootKey</code> will contain the
key associated with the current <code>$root</code> value.</p></li>
<li><p>In addition, when intermediate expressions are used to recurse into the
data model, you can refer to items and keys contained in the outer scopes
using the prefix <code>outer:</code> in the variable name, such as <code>$outer:key</code> or
<code>$outer:item</code>. This prefix can also be compounded (eg.: <code>$outer:outer:key</code>)
to reach different levels of scope.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^associate($people|$item.children|$item.fullName|$root)
</code></pre>

<p>The expression above would iterate over all the values in <code>$people</code>, and for
each person, it would then iterate over the elements contained in the person&rsquo;s
<code>children</code> array. For each of those children, it would create an association
between the <em>key</em>—the value of that child&rsquo;s <code>fullName</code> attribute—and the
<em>value</em>—the <code>$root</code> item (the current person in the iteration from <code>$people</code>).</p>

<p>In other words, the expression above would create a dictionary where the keys
are the full names of children, and the value of each key is the item in
<code>$people</code> representing that child&rsquo;s parent.</p>

<p>In the event that more than one child has a given full name, the corresponding
value in the dictionary will be an array.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/associateWithArray:">+ associateWithArray:</a>, <a href="#//api/name/associateWithSingleValue:">+ associateWithSingleValue:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/associateWithSingleValue:" title="associateWithSingleValue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/associateWithSingleValue:">+&nbsp;associateWithSingleValue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Associates a set of keys with values by iterating over (and potentially
recursing into) a collection object holding an arbitrary data model. If the
association would result in more than one value for a given key, additional
values are ignored and only one value will be returned. Assume
non-deterministic behavior for multiple values.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)associateWithSingleValue:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts three or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an object expression yielding a <em>collection</em> to be
used as the source for the keys and values in the returned dictionary.</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model.</p></li>
<li><p>The second-to-last expression in the input parameters is the <em>key
expression</em>, which yields the keys contained in the returned dictionary.</p></li>
<li><p>The last expression is the <em>value expression</em>, which yields the values
contained in the returned dictionary.</p></li>
</ul>


<p>The intermediate, key and value expressions can refer to portions of the
data model using several pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value of the current item in the innermost
scope being iterated/recursed.</p></li>
<li><p>When iterating the values of a dictionary, the <code>$key</code> variable
can be used to access the key associated with the current <code>$item</code>.</p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model.</p></li>
<li><p>When the data model collection is a dictionary, <code>$rootKey</code> will contain the
key associated with the current <code>$root</code> value.</p></li>
<li><p>In addition, when intermediate expressions are used to recurse into the
data model, you can refer to items and keys contained in the outer scopes
using the prefix <code>outer:</code> in the variable name, such as <code>$outer:key</code> or
<code>$outer:item</code>. This prefix can also be compounded (eg.: <code>$outer:outer:key</code>)
to reach different levels of scope.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^associateWithSingleValue($people|$item.children|$item.fullName|$root)
</code></pre>

<p>The expression above would iterate over all the values in <code>$people</code>, and for
each person, it would then iterate over the elements contained in the person&rsquo;s
<code>children</code> array. For each of those children, it would create an association
between the <em>key</em>—the value of that child&rsquo;s <code>fullName</code> attribute—and the
<em>value</em>—the <code>$root</code> item (the current person in the iteration from <code>$people</code>).</p>

<p>In other words, the expression above would create a dictionary where the keys
are the full names of children, and the value of each key is the item in
<code>$people</code> representing that child&rsquo;s parent.</p>

<p>Because this function associates a given key with at most one value, in the
event that more than one child has a given full name, some values will be
ignored.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/associateWithArray:">+ associateWithArray:</a>, <a href="#//api/name/associate:">+ associate:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/associateWithArray:" title="associateWithArray:"></a>
	<h3 class="method-title"><code><a href="#//api/name/associateWithArray:">+&nbsp;associateWithArray:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Associates a set of keys with values by iterating over (and potentially
recursing into) a collection object holding an arbitrary data model. The
value of each key will always be an array, even if the key only maps to a
single value.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)associateWithArray:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts three or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an object expression yielding a <em>collection</em> to be
used as the source for the keys and values in the returned dictionary.</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model.</p></li>
<li><p>The second-to-last expression in the input parameters is the <em>key
expression</em>, which yields the keys contained in the returned dictionary.</p></li>
<li><p>The last expression is the <em>value expression</em>, which yields the values
contained in the returned dictionary.</p></li>
</ul>


<p>The intermediate, key and value expressions can refer to portions of the
data model using several pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value of the current item in the innermost
scope being iterated/recursed.</p></li>
<li><p>When iterating the values of a dictionary, the <code>$key</code> variable
can be used to access the key associated with the current <code>$item</code>.</p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model.</p></li>
<li><p>When the data model collection is a dictionary, <code>$rootKey</code> will contain the
key associated with the current <code>$root</code> value.</p></li>
<li><p>In addition, when intermediate expressions are used to recurse into the
data model, you can refer to items and keys contained in the outer scopes
using the prefix <code>outer:</code> in the variable name, such as <code>$outer:key</code> or
<code>$outer:item</code>. This prefix can also be compounded (eg.: <code>$outer:outer:key</code>)
to reach different levels of scope.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^associateWithArray($people|$item.children|$item.fullName|$root)
</code></pre>

<p>The expression above would iterate over all the values in <code>$people</code>, and for
each person, it would then iterate over the elements contained in the person&rsquo;s
<code>children</code> array. For each of those children, it would create an association
between the <em>key</em>—the value of that child&rsquo;s <code>fullName</code> attribute—and the
<em>value</em>—the <code>$root</code> item (the current person in the iteration from <code>$people</code>).</p>

<p>In other words, the expression above would create a dictionary where the keys
are the full names of children, and the value of each key is the item in
<code>$people</code> representing that child&rsquo;s parent.</p>

<p>Regardless of whether or not a given key has multiple values, each key
in the returned dictionary will have an array value.</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/associate:">+ associate:</a>, <a href="#//api/name/associateWithSingleValue:">+ associateWithSingleValue:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Sorting" name="task_Sorting"></a>
						<h2 class="task-title">Sorting</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/sort:" title="sort:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sort:">+&nbsp;sort:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns an array containing the sorted values of a collection object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)sort:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The function result.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts between one and three expressions as
input parameters:</p>

<ul>
<li><p>The <em>data model</em>, an object expression yielding the collection object whose
 sorted values are to be returned.</p></li>
<li><p>An optional <em>sort key</em>, an expression indicating the value within <em>data
 model</em> that should be used for the basis of sorting. If omitted, the
 default value is <code>$item</code>, meaning that the value itself should be
 used for sorting. Subvalues of <code>$item</code> may also be specified. This
 parameter must be provided when the <em>descending order specifier</em>
 parameter is used.</p></li>
<li><p>An optional <em>descending order specifier</em>. If this string expression yields
 the value &ldquo;<code>desc</code>&rdquo;, sorting will occur in descending order. If this
 parameter is omitted or if the value is anything else, sorting will occur
 in the default ascending order.</p></li>
</ul>


<p>Note that this method sorts using MBML logical comparators, the behavior
of which differs from that of the <code>compare:</code> method due to Mockingbird&rsquo;s
use of implicit type conversions. The comparison mechanism used is exposed
via the <a href="../Classes/MBExpression.html#//api/name/compareLeftValue:againstRightValue:"><code>[MBExpression compareLeftValue:againstRightValue:]</code></a> method.</p>

<h4>Expression usage</h4>

<p>Assume <code>$buildings</code> represents a collection object whose members have a
<code>height</code> property indicating the corresponding building&rsquo;s height in feet:</p>

<pre><code>^sort($buildings|$item.height|desc)
</code></pre>

<p>The expression above would return an array containing each item in <code>$building</code>
sorted from tallest to shortest.</p>

<pre><code>^sort(^array(z|x|a|c|y|b))
</code></pre>

<p>The expression above yields the array: [&ldquo;<code>a</code>&rdquo;, &ldquo;<code>b</code>&rdquo;, &ldquo;<code>c</code>&rdquo;, &ldquo;<code>x</code>&rdquo;, &ldquo;<code>y</code>&rdquo;,
&ldquo;<code>z</code>&rdquo;].</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Removing duplicate values" name="task_Removing duplicate values"></a>
						<h2 class="task-title">Removing duplicate values</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/unique:" title="unique:"></a>
	<h3 class="method-title"><code><a href="#//api/name/unique:">+&nbsp;unique:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Iterates over the values supplied by the passed-in enumerator, and returns an
array containing the unique values encountered.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)unique:(id)<em>param</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>param</code></th>
						<td><p>The function&rsquo;s input parameter.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing the unique values in the input collection.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This function accepts a single Mockingbird expression, an <em>input collection</em>
that is expected to yield an object conforming to the <code>NSFastEnumeration</code>
protocol.</p>

<p>The values in the returned array will be in the same order that they were
supplied by the enumeration.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$animals</code> is an array with three elements: the strings &ldquo;<code>Duck</code>&rdquo;,
&ldquo;<code>Duck</code>&rdquo; and &ldquo;<code>Goose</code>&rdquo;.</p>

<pre><code>^unique($animals)
</code></pre>

<p>The expression above would return an array containing two strings: &ldquo;<code>Duck</code>&rdquo;
and &ldquo;<code>Goose</code>&rdquo;, in that order.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Reversing the contents of an array" name="task_Reversing the contents of an array"></a>
						<h2 class="task-title">Reversing the contents of an array</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/reverse:" title="reverse:"></a>
	<h3 class="method-title"><code><a href="#//api/name/reverse:">+&nbsp;reverse:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a new <code>NSArray</code> by reversing the order of the items in the passed-in
array.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)reverse:(id)<em>param</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>param</code></th>
						<td><p>The function&rsquo;s input parameter.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing the reversed values of the input array.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This function accepts as a parameter a single Mockingbird object expression,
the <em>input array</em>, which is expected to yield an <code>NSArray</code> instance.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$animals</code> is an array with three elements: the strings &ldquo;<code>Duck</code>&rdquo;,
&ldquo;<code>Duck</code>&rdquo; and &ldquo;<code>Goose</code>&rdquo;.</p>

<pre><code>^reverse($animals)
</code></pre>

<p>The expression above would return an array containing the strings &ldquo;<code>Goose</code>&rdquo;,
&ldquo;<code>Duck</code>&rdquo; and &ldquo;<code>Duck</code>&rdquo; in that order.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Reducing an array of items" name="task_Reducing an array of items"></a>
						<h2 class="task-title">Reducing an array of items</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/reduce:" title="reduce:"></a>
	<h3 class="method-title"><code><a href="#//api/name/reduce:">+&nbsp;reduce:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reduce an array of items into a single item.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)reduce:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>The result of the reduction.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts 3 pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>source array</em>, an object expression expected to yield an <code>NSArray</code>
 instance</p></li>
<li><p>The <em>initial value</em>, an object expression yielding the initial value for
 the reduce operation</p></li>
<li><p>The <em>combining expression</em>, an object expression yielding the result of
 combining the <em>current value</em> with the current item in the array.</p></li>
</ul>


<p>The return value is an array whose items are constructed by iterating over the
source array and for each item in the array, evaluating the combining
expression.</p>

<p>The combining expression may refer to the <em>current reduced value</em> using
<code>$currentValue</code>. The current reduced value is the result of the previous
evaluation of the combining expression. For the first item in the source
array, the combining expression has not yet been evaluated, so the
initial value is used as <code>$currentValue</code>.</p>

<h4>Expression usage</h4>

<pre><code>^reduce(^arrayFilledWithIntegers(1|10)|0|#($currentValue + $item))
</code></pre>

<p>The expression above would return the result <code>55</code>.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="Distributing values" name="task_Distributing values"></a>
						<h2 class="task-title">Distributing values</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/distributeArrayElements:" title="distributeArrayElements:"></a>
	<h3 class="method-title"><code><a href="#//api/name/distributeArrayElements:">+&nbsp;distributeArrayElements:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Distributes the elements contained in a single input array across multiple
arrays.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)distributeArrayElements:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing <em>returned array count</em> arrays containing the
            elements distributed from <em>source array</em>.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>source array</em>, an object expression yielding an array.</p></li>
<li><p>The <em>returned array count</em>, a numeric expression specifying the number of
arrays across which to distribute the elements in <em>source array</em>. This
expression will be interpreted as integer, and must be <code>1</code> or greater.</p></li>
</ul>


<p>The <em>source array</em> is iterated, and each item it contains is distributed across
<em>returned array count</em> arrays in sequence.</p>

<p>The function will always return the number of arrays specified by <em>returned
array count</em>. If <em>source array</em> contains fewer elements than <em>returned array
count</em>, one or more of the returned arrays will be empty.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$newYorkTeams</code> is an array with five elements: the strings
&ldquo;<code>Yankees</code>&rdquo;, &ldquo;<code>Mets</code>&rdquo;, &ldquo;<code>Knicks</code>&rdquo;, <code>Rangers</code> and &ldquo;<code>Nets</code>&rdquo; in that
order.</p>

<pre><code>^distributeArrayElements($newYorkTeams|2)
</code></pre>

<p>The expression above would return an array containing two arrays, where the
first array contains three items (&ldquo;<code>Yankees</code>&rdquo;, &ldquo;<code>Knicks</code>&rdquo; and &ldquo;<code>Nets</code>&rdquo;) and
the second array contains two (&ldquo;<code>Mets</code>&rdquo; and &ldquo;<code>Rangers</code>&rdquo;).</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/groupArrayElements:">+ groupArrayElements:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/groupArrayElements:" title="groupArrayElements:"></a>
	<h3 class="method-title"><code><a href="#//api/name/groupArrayElements:">+&nbsp;groupArrayElements:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Groups the elements in a single array into multiple arrays.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (id)groupArrayElements:(NSArray *)<em>params</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>params</code></th>
						<td><p>The function&rsquo;s input parameters.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>An array containing one or more <em>group arrays</em>.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>source array</em>, an object expression yielding an <code>NSArray</code>.</p></li>
<li><p>The <em>group size</em>, a numeric expression specifying the maximum number of items
to allow in a single group. This expression will be interpreted as integer
value, and must be <code>1</code> or greater.</p></li>
</ul>


<p>The source array is iterated, and for each <em>group size</em> number of items
encountered, a new <em>group array</em> is created containing just those items.</p>

<p>The return value is an array containing one or more group arrays created while
iterating the source array.</p>

<p>Unless <em>source array</em> contains an exact multiple of <em>group size</em> number of
items, the last group array will contain fewer than <em>group size</em> number of
items.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$newYorkTeams</code> is an array with five elements: the strings
&ldquo;<code>Yankees</code>&rdquo;, &ldquo;<code>Mets</code>&rdquo;, &ldquo;<code>Knicks</code>&rdquo;, <code>Rangers</code> and &ldquo;<code>Nets</code>&rdquo; in that
order.</p>

<pre><code>^groupArrayElements($newYorkTeams|2)
</code></pre>

<p>The expression above would return an array containing three arrays, where the
first array contains two items (&ldquo;<code>Yankees</code>&rdquo; and &ldquo;<code>Mets</code>&rdquo;), the second array
contains two items (&ldquo;<code>Knicks</code>&rdquo; and &ldquo;<code>Rangers</code>&rdquo;), and the third array contains
one item (&ldquo;<code>Nets</code>&rdquo;).</p>
			</div>
			

			

			
			<div class="method-subsection see-also-section">
				<h4 class="method-subtitle">See Also</h4>
				<ul>
					
					<li><code><p><a href="#//api/name/distributeArrayElements:">+ distributeArrayElements:</a></p></code></li>
					
				</ul>
			</div>
			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MBMLDataProcessingFunctions.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2015 Gilt Groupe. All rights reserved. Updated: 2015-02-04</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1333)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>